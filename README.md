# ifacegen
Ifacegen generates skeleton code of a type to satisfy an interface.

## Code Snippet
You can use `ifacegen` to generate method stubs of an interface.

For example, to implement sort.Interface of a type `fooSlice`, you run `ifacegen` to generate the method stubs,
```
ifacegen -r fooSlice -i sort.Interface
```

This generates the following code snippet and print to stdout,
```
func (m fooSlice) Len() int {
}

func (m fooSlice) Less(i int, j int) bool {
}

func (m fooSlice) Swap(i int, j int) {
}
```
Now you can fill in the implementation details of these methods.

## Mock
Ifacegen can generate mock struct to satisfy an interface as well.

For example, to mock `net.Conn`, you run `ifacegen` to generate a mock struct,
```
ifacegen -p mynet -i net.Conn -o mynet_mock.go
```

This generates a file `mynet_mock.go` with the code,
```
// @generated by ifacegen

package mynet

import (
	"net"
	"sync/atomic"
	"testing"
	"time"
)

const (
	callClose            = 0
	callLocalAddr        = 1
	callRead             = 2
	callRemoteAddr       = 3
	callSetDeadline      = 4
	callSetReadDeadline  = 5
	callSetWriteDeadline = 6
	callWrite            = 7
)

type ConnMock struct {
	T            *testing.T
	FailIfNotSet bool

	CloseMock            func() error
	LocalAddrMock        func() net.Addr
	ReadMock             func(b []byte) (n int, err error)
	RemoteAddrMock       func() net.Addr
	SetDeadlineMock      func(t time.Time) error
	SetReadDeadlineMock  func(t time.Time) error
	SetWriteDeadlineMock func(t time.Time) error
	WriteMock            func(b []byte) (n int, err error)

	callCounts [8]int32
}

func (m *ConnMock) Close() (err error) {
	atomic.AddInt32(&m.callCounts[callClose], 1)
	if m.CloseMock == nil {
		if m.FailIfNotSet {
			m.T.Error("Close is not mocked")
		}
		return err
	}
	return m.CloseMock()
}

func (m *ConnMock) CloseCallCount() int {
	return int(atomic.LoadInt32(&m.callCounts[callClose]))
}

func (m *ConnMock) LocalAddr() (r0 net.Addr) {
	atomic.AddInt32(&m.callCounts[callLocalAddr], 1)
	if m.LocalAddrMock == nil {
		if m.FailIfNotSet {
			m.T.Error("LocalAddr is not mocked")
		}
		return r0
	}
	return m.LocalAddrMock()
}

func (m *ConnMock) LocalAddrCallCount() int {
	return int(atomic.LoadInt32(&m.callCounts[callLocalAddr]))
}

func (m *ConnMock) Read(b []byte) (n int, err error) {
	atomic.AddInt32(&m.callCounts[callRead], 1)
	if m.ReadMock == nil {
		if m.FailIfNotSet {
			m.T.Error("Read is not mocked")
		}
		return n, err
	}
	return m.ReadMock(b)
}

func (m *ConnMock) ReadCallCount() int {
	return int(atomic.LoadInt32(&m.callCounts[callRead]))
}

func (m *ConnMock) RemoteAddr() (r0 net.Addr) {
	atomic.AddInt32(&m.callCounts[callRemoteAddr], 1)
	if m.RemoteAddrMock == nil {
		if m.FailIfNotSet {
			m.T.Error("RemoteAddr is not mocked")
		}
		return r0
	}
	return m.RemoteAddrMock()
}

func (m *ConnMock) RemoteAddrCallCount() int {
	return int(atomic.LoadInt32(&m.callCounts[callRemoteAddr]))
}

func (m *ConnMock) SetDeadline(t time.Time) (err error) {
	atomic.AddInt32(&m.callCounts[callSetDeadline], 1)
	if m.SetDeadlineMock == nil {
		if m.FailIfNotSet {
			m.T.Error("SetDeadline is not mocked")
		}
		return err
	}
	return m.SetDeadlineMock(t)
}

func (m *ConnMock) SetDeadlineCallCount() int {
	return int(atomic.LoadInt32(&m.callCounts[callSetDeadline]))
}

func (m *ConnMock) SetReadDeadline(t time.Time) (err error) {
	atomic.AddInt32(&m.callCounts[callSetReadDeadline], 1)
	if m.SetReadDeadlineMock == nil {
		if m.FailIfNotSet {
			m.T.Error("SetReadDeadline is not mocked")
		}
		return err
	}
	return m.SetReadDeadlineMock(t)
}

func (m *ConnMock) SetReadDeadlineCallCount() int {
	return int(atomic.LoadInt32(&m.callCounts[callSetReadDeadline]))
}

func (m *ConnMock) SetWriteDeadline(t time.Time) (err error) {
	atomic.AddInt32(&m.callCounts[callSetWriteDeadline], 1)
	if m.SetWriteDeadlineMock == nil {
		if m.FailIfNotSet {
			m.T.Error("SetWriteDeadline is not mocked")
		}
		return err
	}
	return m.SetWriteDeadlineMock(t)
}

func (m *ConnMock) SetWriteDeadlineCallCount() int {
	return int(atomic.LoadInt32(&m.callCounts[callSetWriteDeadline]))
}

func (m *ConnMock) Write(b []byte) (n int, err error) {
	atomic.AddInt32(&m.callCounts[callWrite], 1)
	if m.WriteMock == nil {
		if m.FailIfNotSet {
			m.T.Error("Write is not mocked")
		}
		return n, err
	}
	return m.WriteMock(b)
}

func (m *ConnMock) WriteCallCount() int {
	return int(atomic.LoadInt32(&m.callCounts[callWrite]))
}
```

Now you can use `ConnMock` and set these `*Mock` funcs in your tests. For example, to test `Read`,
```
func TestFoo(t *testing.T) {
  conn := &ConnMock{
    FailIfNotSet: true,
    ReadMock: func(b []byte) (int, error) {
      return copy(b, "hello"), nil
    },
  }
  ...
  got := make([]byte, 10)
  n, err := conn.Read(got)
  ...
}
```

## Usage

```$ ifacegen -h
Usage of ifacegen:
  -i string
    	interface name, {import path}.{interface}, e.g. net/http.Handler; required
  -o string
    	name of output file, default to os.Stdout
  -p string
    	package name of the mock struct
  -r string
    	name of receiver, default to *{Interface}{Gen|Mock}
```

where,
- `{import path}` is the package path in code, e.g. `net/http`, `golang.org/x/crypto/nacl/box`. Ifacegen handles vendor.
- if you want the receiver to be point receiver, prefix the name with `*`, e.g. `-r '*MyHandler'`. The default receiver is point receiver.
- if `-p` is specified, the mock struct is generated; otherwise code snippet is generated.

